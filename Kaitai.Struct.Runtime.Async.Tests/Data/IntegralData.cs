using System.Collections.Generic;
using System.Linq;

namespace Kaitai.Struct.Runtime.Async.Tests
{
    public class IntegralData
    {
        public static IEnumerable<object[]> Integral1Data =>
            new List<(sbyte expected, byte[] streamContent)>
            {
                (0x00, new byte[] {0x00}),
                (0x01, new byte[] {0x01}),
                (0x7F, new byte[] {0x7F}),
                (unchecked((sbyte) 0xFF), new byte[] {0xFF})
            }.Select(t => new object[] {t.expected, t.streamContent});

        public static IEnumerable<object[]> Integral2Data =>
            new List<(short expected, byte[] streamContent)>
            {
                (0x00, new byte[] {0x00, 0x00}),
                (0x01, new byte[] {0x00, 0x01}),
                (0xFF, new byte[] {0x00, 0xFF}),
                (0x01_FF, new byte[] {0x01, 0xFF}),
                (0x7F_FF, new byte[] {0x7F, 0xFF}),
                (unchecked((short) 0xFF_FF), new byte[] {0xFF, 0xFF})
            }.Select(t => new object[] {t.expected, t.streamContent});

        public static IEnumerable<object[]> Integral4Data =>
            new List<(int expected, byte[] streamContent)>
            {
                (0x00, new byte[] {0x00, 0x00, 0x00, 0x00}),
                (0x01, new byte[] {0x00, 0x00, 0x00, 0x01}),
                (0xFF, new byte[] {0x00, 0x00, 0x00, 0xFF}),
                (0x01_FF, new byte[] {0x00, 0x00, 0x01, 0xFF}),
                (0x7F_FF, new byte[] {0x00, 0x00, 0x7F, 0xFF}),
                (0xFF_FF, new byte[] {0x00, 0x00, 0xFF, 0xFF}),
                (0x01_FF_FF, new byte[] {0x00, 0x01, 0xFF, 0xFF}),
                (0x7F_FF_FF, new byte[] {0x00, 0x7F, 0xFF, 0xFF}),
                (0xFF_FF_FF, new byte[] {0x00, 0xFF, 0xFF, 0xFF}),
                (0x01_FF_FF_FF, new byte[] {0x01, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF, new byte[] {0x7F, 0xFF, 0xFF, 0xFF}),
                (unchecked((int) 0xFF_FF_FF_FF), new byte[] {0xFF, 0xFF, 0xFF, 0xFF})
            }.Select(t => new object[] {t.expected, t.streamContent});

        public static IEnumerable<object[]> Integral8Data =>
            new List<(long expected, byte[] streamContent)>
            {
                (0, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
                (1, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}),
                (0xFF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}),

                (0x01_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF}),
                (0x7F_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF}),
                (0xFF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF}),

                (0x01_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF}),
                (0x7F_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF}),
                (0xFF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF}),

                (0x01_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF}),
                (0xFF_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF}),

                (0x01_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0xFF_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),

                (0x01_FF_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0xFF_FF_FF_FF_FF_FF, new byte[] {0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),

                (0x01_FF_FF_FF_FF_FF_FF, new byte[] {0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF_FF_FF_FF, new byte[] {0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0xFF_FF_FF_FF_FF_FF_FF, new byte[] {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),

                (0x01_FF_FF_FF_FF_FF_FF_FF, new byte[] {0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (0x7F_FF_FF_FF_FF_FF_FF_FF, new byte[] {0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}),
                (unchecked((long) 0xFF_FF_FF_FF_FF_FF_FF_FF),
                    new byte[] {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
            }.Select(t => new object[] {t.expected, t.streamContent});
    }
}